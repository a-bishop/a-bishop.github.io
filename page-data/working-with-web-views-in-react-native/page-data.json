{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/working-with-web-views-in-react-native","result":{"data":{"post":{"__typename":"MdxPost","slug":"/working-with-web-views-in-react-native","title":"Working with WebViews in React Native","date":"09.06.2019","tags":[{"name":"React","slug":"react"},{"name":"React Native","slug":"react-native"},{"name":"JavaScript","slug":"java-script"},{"name":"iOS","slug":"i-os"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Working with WebViews in React Native\",\n  \"date\": \"2019-06-09T00:00:00.000Z\",\n  \"tags\": [\"React\", \"React Native\", \"JavaScript\", \"iOS\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Sometimes it is too resource-intensive to recreate the interface and business logic of a complex web application in React Native. For those instances, the framework allows us to simply embed existing web pages in our apps with the WebView component. Let's look at some of the functionality exposed through the WebView API.\"), mdx(\"h4\", null, \"Getting started\"), mdx(\"p\", null, \"The React Native team is planning the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://facebook.github.io/react-native/docs/webview\"\n  }), \"imminent removal of WebViews\"), \" from the core library as part of its efforts to reduce the framework's size. As a result, we'll need to import the WebView component from a separate package, namely \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-native-webview\"), \". So, let's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm install\"), \" it into our existing React Native project to get started.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-noLineNumbers\"\n  }), \"npm install react-native-webview\\n\")), mdx(\"p\", null, \"Then, import it into the component where we'd like to render a WebView.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-noLineNumbers\"\n  }), \"import { WebView } from \\\"react-native-webview\\\"\\n\")), mdx(\"p\", null, \"Using the WebView component couldn't be easier. Just pass it a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"source\"), \" prop, which will be an object with key of \\\"uri\\\" and a value of the web address to render in the component.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-noLineNumbers\"\n  }), \"<WebView source={{ uri: \\\"https://example.com\\\" }} />\\n\")), mdx(\"h4\", null, \"Useful WebView Properties and APIs\"), mdx(\"p\", null, \"Once we have the WebView component set up, maybe we want to show users a placeholder while it is rendering. For this, we can hook into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onLoadProgress\"), \" prop and use the progress attribute of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nativeEvent\"), \" object to determine how long to display our placeholder, which in this case is an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ActivityIndicator\"), \" component.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import { useState } from \\\"react\\\";\\nimport { ActivityIndicator, View } from \\\"react-native\\\";\\n\\nconst WebViewComponent = () => {\\n  const [progress, setProgress] = useState(0.0);\\n\\n  return (\\n    <>\\n    <WebView\\n        source={{ uri: \\\"https://example.com\\\" }}\\n        onLoadProgress={event => {\\n          setProgress(event.nativeEvent.progress);\\n        }}\\n    />;\\n    {\\n        progress < 0.99 ? (\\n        <View style={{ justifyContent: \\\"center\\\", alignItems: \\\"center\\\" }}>\\n            <ActivityIndicator size=\\\"large\\\" color=\\\"khaki\\\" />\\n        </View>\\n        ) : null;\\n    }\\n    </>\\n  )\\n};\\n\")), mdx(\"p\", null, \"Another useful prop when working with WebViews is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onNavigationStateChange\"), \". With this prop, we can expose an object representing the navigation state of the component, which will let us do things like create custom forward and back navigation buttons and listen for url changes. To use this prop, you'll also need to define a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ref\"), \" to uniquely identify the instance of the WebView.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import { Button } from \\\"react-native-elements\\\";\\nimport { useRef, useState } from \\\"react\\\";\\nimport { View, Dimensions } from \\\"react-native\\\";\\nimport { WebView } from \\\"react-native-webview\\\";\\n\\nconst WebViewComponent = () => {\\n  const [canGoBack, setCanGoBack] = useState(false);\\n  const [canGoForward, setCanGoForward] = useState(false);\\n  const [currentUrl, setCurrentUrl] = useState(\\\"\\\");\\n\\n  const { width } = Dimensions.get(\\\"window\\\");\\n\\n  const wvRef = useRef();\\n\\n  function backHandler() {\\n    if (wvRef.current) wvRef.current.goBack();\\n  }\\n\\n  function forwardHandler() {\\n    if (wvRef.current) wvRef.current.goForward();\\n  }\\n\\n  // listen for url changes and trigger an action on certain endpoint\\n  useEffect(() => {\\n    if (currentUrl.match(/\\\\/my-target-endpoint\\\\//)) {\\n      console.log(currentUrl);\\n    }\\n  }, [currentUrl]);\\n\\n  return (\\n    <>\\n      <View style={{ flexDirection: \\\"row\\\", height: 50, width: width }}>\\n        <Button\\n          title=\\\"< Back\\\"\\n          disabled={!canGoBack}\\n          onPress={backHandler}\\n          accessibilityLabel=\\\"Go back\\\"\\n        />\\n        <Button\\n          title=\\\"> Forward\\\"\\n          disabled={!canGoForward}\\n          onPress={forwardHandler}\\n          accessibilityLabel=\\\"Go forward\\\"\\n        />\\n      </View>\\n      <WebView\\n        ref={wvRef}\\n        source={{ uri: \\\"https://example.com\\\" }}\\n        onNavigationStateChange={navState => {\\n          setCanGoBack(navState.canGoBack);\\n          setCanGoForward(navState.canGoForward);\\n          setCurrentUrl(navState.url);\\n        }}\\n      />\\n    </>\\n  );\\n};\\n\")), mdx(\"p\", null, \"One of the most powerful features of WebViews is the ability to inject JavaScript to do things like remove page elements, disable buttons, and attach event handlers to the JavaScript code within the webpage. For this functionality there are two props that the WebView can take, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"injectJavascript\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"injectedJavascript\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InjectedJavascript\"), \" only gets evaluated once on load of the WebView, so for most use-cases you'll probably want to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"injectJavascript\"), \" API, which runs for the full lifetime of the component. I encountered errors when trying to inject the JavaScript directly, until I started experimenting with wrapping the code in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTimeout()\"), \" function to add it to the event loop.\"), mdx(\"p\", null, \"Used in conjuction with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onMessage\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"postMessage\"), \" APIs, one can create two-way communication channels between the React Native code and the WebView quite easily. In the example below, the WebView component communicates to React Native when it detects that a user has submitted a form element on the webpage.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import { useRef, useState } from \\\"react\\\";\\nimport { WebView } from \\\"react-native-webview\\\";\\n\\nconst WebViewComponent = () => {\\n  const [formSubmitted, setFormSubmitted] = useState(false);\\n\\n  const wvRef = useRef();\\n\\n  const jsToInject = `\\n    setTimeout(() => {\\n        document.getElementById(\\\"submit-form\\\").addEventListener(\\\"submit\\\", function(){\\n            window.ReactNativeWebView.postMessage(\\\"form submitted\\\")\\n        });\\n        true;\\n    }, 0);\\n  `;\\n\\n  if (wvRef.current !== undefined) {\\n    wvRef.current.injectJavaScript(jsToInject);\\n  }\\n\\n  return (\\n    <>\\n      <WebView\\n        ref={wvRef}\\n        source={{ uri: \\\"https://a-page-with-a-form.com\\\" }}\\n        onMessage={event => {\\n          console.log(event.nativeEvent.data); // \\\"form submitted\\\"\\n          setFormSubmitted(true);\\n        }}\\n      />\\n    </>\\n  );\\n};\\n\")), mdx(\"h4\", null, \"Conclusion\"), mdx(\"p\", null, \"WebViews are not the most performant way to write a React Native application, but they provide a useful bridge between web interfaces and native code when it would be impractical to fully rebuild the interface natively. Luckily, the WebView component exposes many useful APIs that let us make this bridge happen more seamlessly.\"), mdx(\"p\", null, \"Hopefully this post has given you some ideas for how to integrate a WebView into your next React Native application. Check out the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/react-native-community/react-native-webview/blob/master/docs/Reference.md\"\n  }), \"React Native WebView API reference docs\"), \" for more ideas and examples.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Sometimes it is too resource-intensive to recreate the interface and business logic of a complex web application in React Native. For thoseâ€¦","timeToRead":2,"banner":null}},"pageContext":{"slug":"/working-with-web-views-in-react-native","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["1654422363","3090400250","3090400250"]}