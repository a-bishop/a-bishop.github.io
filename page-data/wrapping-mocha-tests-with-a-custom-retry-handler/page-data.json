{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/wrapping-mocha-tests-with-a-custom-retry-handler","result":{"data":{"post":{"__typename":"MdxPost","slug":"/wrapping-mocha-tests-with-a-custom-retry-handler","title":"Wrapping Mocha Tests With A Custom Retry Handler","date":"14.12.2019","tags":[{"name":"JavaScript","slug":"java-script"},{"name":"Mocha","slug":"mocha"},{"name":"Chai","slug":"chai"},{"name":"Testing","slug":"testing"}],"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Wrapping Mocha Tests With A Custom Retry Handler\",\n  \"date\": \"2019-12-14T00:00:00.000Z\",\n  \"tags\": [\"JavaScript\", \"Mocha\", \"Chai\", \"Testing\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When writing integration tests for interactions with external services, it can be difficult to predict the amount of time that these processes will take. As a result, it is tempting to add lengthy waits to ensure that the side effects of each network call have completed before moving on to the next step of the test.\"), mdx(\"p\", null, \"For instance, a request sent to an endpoint that responds via webhook and triggers a database update could take longer than expected to complete. With the Mocha testing framework, the naive solution would be to add a lengthy \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTimeout\"), \" function after the external call.\"), mdx(\"h4\", null, \"Retry handlers\"), mdx(\"p\", null, \"While writing integration tests in Mocha for the payment platform at Change.org, I implemented a simple higher-order function that would allow us to avoid the use of these heavy-handed timeouts. We wanted to be able to retry the test if it failed, using increasing timeouts calculated on each run.\"), mdx(\"p\", null, \"The idea was to wrap the test in a function that takes in the number of attempts desired, and returns a test handler with a function argument that, when called, calculates an adjusted timeout based on the attempt count and a multiplication factor (which can be configured). This function is aware of the attempt count on each test run because it has been bound via closure in the handler.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=test_utils.js\"\n  }, \"// the test wrapper\\nfunction withAttempts(totalAttempts, testFunc) {\\n  return async function() {\\n\\n    // grab the retry count from mocha's test instance\\n    const retryCount = this.runnable().currentRetry();\\n\\n    // if it's the first run of the test, \\n    // set the number of desired retries.\\n    if (retryCount === 0) {\\n      this.retries(totalAttempts - 1);\\n    } else {\\n      debug(`retry: ${this.test.title}`);\\n    }\\n\\n    const attemptCount = retryCount + 1;\\n\\n    // define a weightedSleep function, \\n    // with the attemptCount bound via closure\\n    function weightedSleep(milliseconds, options) {\\n      return sleep(\\n        getWeightedValue(milliseconds, { attemptCount, ...options })\\n      );\\n    }\\n\\n    try {\\n      // run the test and pass in an object with \\n      // the timeout function and the attempt count\\n      return await testFunc({ weightedSleep, attemptCount });\\n    } catch (e) {\\n      debug(`error: ${e}`);\\n      // throwing the caught error will retry the test\\n      throw e;\\n    }\\n  };\\n}\\n\\nfunction sleep(milliseconds) {\\n  return new Promise(resolve => setTimeout(resolve, milliseconds));\\n}\\n\\n// Increase a value by the given factor based on the attempt count\\nfunction getWeightedValue(value, { attemptCount = 1, incrementFactor = 0.5 }) {\\n  return attemptCount > 1\\n    ? value + value * attemptCount * incrementFactor\\n    : value;\\n}\\n\")), mdx(\"p\", null, \"And here's how the wrapper would be used in the context of a test:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js:title=my_integration.test.js\"\n  }, \"describe('My Integration', function() {\\n    context('when I make a network request with side effects', () => {\\n        it('the correct value is eventually recorded in my database', \\n            withAttempts(3, async ({ weightedSleep }) => {\\n                // make a time-consuming network call with side effects\\n                await fetchSomethingTimeConsuming();\\n                // set a timeout of 5 seconds on initial run, with steadily\\n                // increasing timeouts on subsequent runs\\n                await weightedSleep(5000);\\n                // assert on the value of something that happened as a side effect\\n                // of the network call. If this assertion fails,\\n                // the test will retry with a new weightedSleep function\\n                expect(await getValueInDatabase()).to.equal({foo: 'bar'})\\n            })\\n        )\\n    });\\n}\\n\")), mdx(\"p\", null, \"The nice thing about this pattern is that we can start by writing tests with many retries and low timeouts, and analyze the runs to determine at what timeout threshold the tests become stable.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"When writing integration tests for interactions with external services, it can be difficult to predict the amount of time that theseâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/wrapping-mocha-tests-with-a-custom-retry-handler","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["1654422363","3090400250","3090400250"]}